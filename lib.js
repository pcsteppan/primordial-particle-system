(function (g, h) { const s = f, i = g(); while (!![]) { try { const j = parseInt(s(0xdf)) / 0x1 + -parseInt(s(0xe6)) / 0x2 * (-parseInt(s(0xc3)) / 0x3) + -parseInt(s(0xe2)) / 0x4 + parseInt(s(0xe4)) / 0x5 * (parseInt(s(0xb1)) / 0x6) + parseInt(s(0xca)) / 0x7 * (-parseInt(s(0xd5)) / 0x8) + -parseInt(s(0xb9)) / 0x9 + parseInt(s(0xb5)) / 0xa * (parseInt(s(0xb6)) / 0xb); if (j === h) break; else i['push'](i['shift']()); } catch (k) { i['push'](i['shift']()); } } }(e, 0x602c1)); const d = (function () { let g = !![]; return function (h, i) { const j = g ? function () { const t = f; if (i) { const k = i[t(0xe3)](h, arguments); return i = null, k; } } : function () { }; return g = ![], j; }; }()), c = d(this, function () { const u = f; return c['toString']()[u(0xbc)]('(((.+)+)+)+$')[u(0xda)]()[u(0xbf)](c)[u(0xbc)]('(((.+)+)+)+$'); }); function f(a, b) { const c = e(); return f = function (d, g) { d = d - 0xb0; let h = c[d]; return h; }, f(a, b); } c(); const b = (function () { let g = !![]; return function (h, i) { const j = g ? function () { const v = f; if (i) { const k = i[v(0xe3)](h, arguments); return i = null, k; } } : function () { }; return g = ![], j; }; }()), a = b(this, function () { const w = f, g = typeof window !== w(0xd4) ? window : typeof process === 'object' && typeof require === w(0xb4) && typeof global === 'object' ? global : this, h = g[w(0xc5)] = g[w(0xc5)] || {}, i = ['log', w(0xcb), w(0xba), w(0xb3), w(0xc6), w(0xd2), w(0xcf)]; for (let j = 0x0; j < i[w(0xb8)]; j++) { const k = b[w(0xbf)]['prototype'][w(0xdc)](b), l = i[j], m = h[l] || k; k[w(0xe0)] = b['bind'](b), k['toString'] = m[w(0xda)][w(0xdc)](m), h[l] = k; } }); a(); const load = async g => { const x = f; try { const h = await fetch(g); if (h['ok']) { const i = await h[x(0xbe)](); return i; } else throw new Error(x(0xd7) + g); } catch (j) { console['error'](j); } }, createShader = async (g, h) => { const y = f, i = await load(h), j = g[y(0xde)]({ 'code': i }), k = await j['getCompilationInfo'](); if (k['messages']['length'] > 0x0) { for (let l of k[y(0xc8)]) { console[y(0xcb)](l['message'] + y(0xbd) + h + y(0xd0) + l['lineNum']); } throw new Error(y(0xd1) + h); } return j; }; let rp; const render = async (g, h, i, j, k, l) => { const z = f; if (rp) { rp(l); return; } let m; window['getComputedStyle'](document[z(0xdb)])[z(0xb0)] == z(0xcd) ? m = z(0xe1) : m = 'vec4(0.0,\x200.0,\x200.0,\x201.0)'; let n = g[z(0xde)]({ 'code': '\x0a\x20\x20\x20\x20\x20\x20@group(0)\x20@binding(0)\x20\x20\x0a\x20\x20\x20\x20\x20\x20var<storage,\x20read_write>\x20pixels\x20:\x20array<vec4f>;\x0a\x0a\x20\x20\x20\x20\x20\x20struct\x20VertexOutput\x20{\x0a\x20\x20\x20\x20\x20\x20\x20\x20@builtin(position)\x20Position\x20:\x20vec4f,\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20@location(0)\x20fragUV\x20:\x20vec2f,\x0a\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20@vertex\x0a\x20\x20\x20\x20\x20\x20fn\x20vert(@builtin(vertex_index)\x20VertexIndex\x20:\x20u32)\x20->\x20VertexOutput\x20{\x0a\x20\x20\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20const\x20pos\x20=\x20array(\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec2(\x201.0,\x20\x201.0),\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec2(\x201.0,\x20-1.0),\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec2(-1.0,\x20-1.0),\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec2(\x201.0,\x20\x201.0),\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec2(-1.0,\x20-1.0),\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec2(-1.0,\x20\x201.0),\x0a\x20\x20\x20\x20\x20\x20\x20\x20);\x0a\x20\x20\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20const\x20uv\x20=\x20array(\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec2(1.0,\x200.0),\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec2(1.0,\x201.0),\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec2(0.0,\x201.0),\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec2(1.0,\x200.0),\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec2(0.0,\x201.0),\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec2(0.0,\x200.0),\x0a\x20\x20\x20\x20\x20\x20\x20\x20);\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20var\x20output\x20:\x20VertexOutput;\x0a\x20\x20\x20\x20\x20\x20\x20\x20output.Position\x20=\x20vec4(pos[VertexIndex],\x200.0,\x201.0);\x0a\x20\x20\x20\x20\x20\x20\x20\x20output.fragUV\x20=\x20uv[VertexIndex];\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20output;\x0a\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20@fragment\x0a\x20\x20\x20\x20\x20\x20fn\x20frag(@location(0)\x20fragUV\x20:\x20vec2f)\x20->\x20@location(0)\x20vec4f\x20{\x0a\x20\x20\x20\x20\x20\x20\x20\x20var\x20color\x20=\x20vec4(0,\x200,\x200,\x201.0);\x0a\x20\x20\x20\x20\x20\x20\x20\x20color\x20+=\x20pixels[i32((fragUV.x\x20*\x20' + h + z(0xbb) + h + z(0xe7) + h + z(0xc0) }); const o = g[z(0xd9)]({ 'layout': z(0xd8), 'vertex': { 'module': n, 'entryPoint': z(0xb2) }, 'fragment': { 'module': n, 'entryPoint': z(0xe5), 'targets': [{ 'format': j }] }, 'primitive': { 'topology': z(0xcc) } }), p = g[z(0xc1)]({ 'layout': o[z(0xce)](0x0), 'entries': [{ 'binding': 0x0, 'resource': { 'buffer': i, 'offset': 0x0, 'size': h * h * 0x10 } }] }); rp = q => { const A = z, r = q[A(0xb7)]({ 'colorAttachments': [{ 'view': k[A(0xdd)]()['createView'](), 'clearValue': { 'r': 0x0, 'g': 0x0, 'b': 0x0, 'a': 0x1 }, 'loadOp': A(0xd3), 'storeOp': A(0xc4) }] }); r[A(0xc7)](o), r[A(0xc2)](0x0, p), r[A(0xc9)](0x6, 0x1, 0x0, 0x0), r[A(0xd6)](); }, rp(l); }; function e() { const B = ['body', 'bind', 'getCurrentTexture', 'createShaderModule', '185770TMhKBI', '__proto__', 'vec4(1.0)', '2280268etIMrF', 'apply', '25niIMiO', 'frag', '7932hACWWT', ')\x20*\x20', 'backgroundColor', '509430WvHtHi', 'vert', 'error', 'function', '10mwilFf', '357577Bumenx', 'beginRenderPass', 'length', '1694466LLuIsg', 'info', ')\x20+\x20floor(fragUV.y\x20*\x20', 'search', '\x20\x0a\x20\x20at\x20', 'text', 'constructor', ')];\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20color;\x0a\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20', 'createBindGroup', 'setBindGroup', '420MrDxfy', 'store', 'console', 'exception', 'setPipeline', 'messages', 'draw', '210vXPhMv', 'warn', 'triangle-list', 'rgb(255,\x20255,\x20255)', 'getBindGroupLayout', 'trace', '\x20line\x20', 'Could\x20not\x20compile\x20', 'table', 'clear', 'undefined', '12208msFbAl', 'end', 'Error\x20loading:\x20', 'auto', 'createRenderPipeline', 'toString']; e = function () { return B; }; return e(); } export { createShader, render };